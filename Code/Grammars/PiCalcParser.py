# Generated from PiCalc.g4 by ANTLR 4.7.1
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
        buf.write(u"F\u01e8\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\3\2\5\2 \n\2\3\2\3\2\3\3\3\3\3\3")
        buf.write(u"\7\3\'\n\3\f\3\16\3*\13\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4")
        buf.write(u"\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4")
        buf.write(u"\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4")
        buf.write(u"\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4")
        buf.write(u"\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4")
        buf.write(u"\3\4\3\4\3\4\5\4j\n\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5")
        buf.write(u"s\n\5\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\6\6\177")
        buf.write(u"\n\6\r\6\16\6\u0080\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write(u"\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write(u"\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write(u"\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\6\6\u00b0")
        buf.write(u"\n\6\r\6\16\6\u00b1\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write(u"\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write(u"\6\3\6\3\6\3\6\3\6\3\6\6\6\u00cf\n\6\r\6\16\6\u00d0\3")
        buf.write(u"\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\6\6\u00de")
        buf.write(u"\n\6\r\6\16\6\u00df\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3")
        buf.write(u"\6\3\6\3\6\3\6\6\6\u00ee\n\6\r\6\16\6\u00ef\3\6\3\6\3")
        buf.write(u"\6\5\6\u00f5\n\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write(u"\3\7\5\7\u0101\n\7\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3")
        buf.write(u"\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3")
        buf.write(u"\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3")
        buf.write(u"\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3")
        buf.write(u"\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3")
        buf.write(u"\b\3\b\5\b\u0141\n\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t")
        buf.write(u"\3\t\3\t\5\t\u014d\n\t\3\n\3\n\3\n\3\n\5\n\u0153\n\n")
        buf.write(u"\3\13\3\13\3\13\3\13\5\13\u0159\n\13\3\f\3\f\3\r\3\r")
        buf.write(u"\3\r\3\r\3\r\7\r\u0162\n\r\f\r\16\r\u0165\13\r\3\r\3")
        buf.write(u"\r\3\r\3\r\3\r\3\r\3\r\7\r\u016e\n\r\f\r\16\r\u0171\13")
        buf.write(u"\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\7\r\u017a\n\r\f\r\16\r")
        buf.write(u"\u017d\13\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\7\r\u0186\n\r")
        buf.write(u"\f\r\16\r\u0189\13\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r")
        buf.write(u"\3\r\3\r\6\r\u0195\n\r\r\r\16\r\u0196\3\r\3\r\3\r\3\r")
        buf.write(u"\3\r\3\r\5\r\u019f\n\r\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write(u"\3\16\3\16\5\16\u01a9\n\16\3\16\5\16\u01ac\n\16\3\17")
        buf.write(u"\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3")
        buf.write(u"\17\5\17\u01ba\n\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write(u"\3\17\3\17\3\17\5\17\u01c6\n\17\3\17\3\17\3\17\3\17\3")
        buf.write(u"\17\3\17\6\17\u01ce\n\17\r\17\16\17\u01cf\3\17\3\17\3")
        buf.write(u"\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\6\17\u01dd")
        buf.write(u"\n\17\r\17\16\17\u01de\3\17\3\17\3\17\3\17\3\17\5\17")
        buf.write(u"\u01e6\n\17\3\17\2\2\20\2\4\6\b\n\f\16\20\22\24\26\30")
        buf.write(u"\32\34\2\2\2\u022d\2\37\3\2\2\2\4#\3\2\2\2\6i\3\2\2\2")
        buf.write(u"\br\3\2\2\2\n\u00f4\3\2\2\2\f\u0100\3\2\2\2\16\u0140")
        buf.write(u"\3\2\2\2\20\u014c\3\2\2\2\22\u0152\3\2\2\2\24\u0158\3")
        buf.write(u"\2\2\2\26\u015a\3\2\2\2\30\u019e\3\2\2\2\32\u01ab\3\2")
        buf.write(u"\2\2\34\u01e5\3\2\2\2\36 \5\4\3\2\37\36\3\2\2\2\37 \3")
        buf.write(u"\2\2\2 !\3\2\2\2!\"\5\b\5\2\"\3\3\2\2\2#(\5\6\4\2$%\7")
        buf.write(u"\3\2\2%\'\5\6\4\2&$\3\2\2\2\'*\3\2\2\2(&\3\2\2\2()\3")
        buf.write(u"\2\2\2)\5\3\2\2\2*(\3\2\2\2+,\7E\2\2,-\7\4\2\2-j\5\f")
        buf.write(u"\7\2./\7E\2\2/\60\7\5\2\2\60\61\5\f\7\2\61\62\7\6\2\2")
        buf.write(u"\62\63\5\26\f\2\63\64\7\7\2\2\64\65\5\b\5\2\65j\3\2\2")
        buf.write(u"\2\66\67\7E\2\2\678\7\5\2\289\5\f\7\29:\7\6\2\2:;\5\32")
        buf.write(u"\16\2;<\7\7\2\2<=\5\b\5\2=j\3\2\2\2>?\7E\2\2?@\7\5\2")
        buf.write(u"\2@A\5\f\7\2AB\7\6\2\2BC\5\30\r\2CD\7\7\2\2DE\5\b\5\2")
        buf.write(u"Ej\3\2\2\2FG\7\b\2\2GH\7E\2\2HI\7\t\2\2Ij\5\32\16\2J")
        buf.write(u"K\7\b\2\2KL\7E\2\2LM\7\t\2\2Mj\5\30\r\2NO\7\b\2\2OP\7")
        buf.write(u"E\2\2Pj\5\26\f\2QR\7\b\2\2RS\7E\2\2ST\5\26\f\2TU\7\4")
        buf.write(u"\2\2UV\5\f\7\2Vj\3\2\2\2WX\7\b\2\2XY\7E\2\2Yj\5\32\16")
        buf.write(u"\2Z[\7\b\2\2[\\\7E\2\2\\]\5\32\16\2]^\7\4\2\2^_\5\f\7")
        buf.write(u"\2_j\3\2\2\2`a\7\b\2\2ab\7E\2\2bj\5\30\r\2cd\7\b\2\2")
        buf.write(u"de\7E\2\2ef\5\30\r\2fg\7\4\2\2gh\5\f\7\2hj\3\2\2\2i+")
        buf.write(u"\3\2\2\2i.\3\2\2\2i\66\3\2\2\2i>\3\2\2\2iF\3\2\2\2iJ")
        buf.write(u"\3\2\2\2iN\3\2\2\2iQ\3\2\2\2iW\3\2\2\2iZ\3\2\2\2i`\3")
        buf.write(u"\2\2\2ic\3\2\2\2j\7\3\2\2\2ks\5\n\6\2lm\7\5\2\2mn\5\b")
        buf.write(u"\5\2no\7\n\2\2op\5\b\5\2pq\7\13\2\2qs\3\2\2\2rk\3\2\2")
        buf.write(u"\2rl\3\2\2\2s\t\3\2\2\2tu\7E\2\2uv\7\5\2\2vw\5\f\7\2")
        buf.write(u"wx\7\13\2\2x\u00f5\3\2\2\2y\u00f5\7\f\2\2z{\7\r\2\2{")
        buf.write(u"~\5\f\7\2|}\7\3\2\2}\177\5\f\7\2~|\3\2\2\2\177\u0080")
        buf.write(u"\3\2\2\2\u0080~\3\2\2\2\u0080\u0081\3\2\2\2\u0081\u0082")
        buf.write(u"\3\2\2\2\u0082\u0083\7\16\2\2\u0083\u0084\5\n\6\2\u0084")
        buf.write(u"\u00f5\3\2\2\2\u0085\u0086\7\17\2\2\u0086\u0087\5\f\7")
        buf.write(u"\2\u0087\u0088\7\6\2\2\u0088\u0089\5\26\f\2\u0089\u008a")
        buf.write(u"\7\20\2\2\u008a\u008b\5\b\5\2\u008b\u008c\7\13\2\2\u008c")
        buf.write(u"\u00f5\3\2\2\2\u008d\u008e\7\17\2\2\u008e\u008f\5\f\7")
        buf.write(u"\2\u008f\u0090\5\f\7\2\u0090\u0091\7\6\2\2\u0091\u0092")
        buf.write(u"\5\34\17\2\u0092\u0093\7\20\2\2\u0093\u0094\5\b\5\2\u0094")
        buf.write(u"\u0095\7\13\2\2\u0095\u00f5\3\2\2\2\u0096\u0097\7\17")
        buf.write(u"\2\2\u0097\u0098\5\f\7\2\u0098\u0099\7\6\2\2\u0099\u009a")
        buf.write(u"\5\32\16\2\u009a\u009b\7\20\2\2\u009b\u009c\5\b\5\2\u009c")
        buf.write(u"\u009d\7\13\2\2\u009d\u00f5\3\2\2\2\u009e\u009f\7\21")
        buf.write(u"\2\2\u009f\u00a0\5\f\7\2\u00a0\u00a1\7\3\2\2\u00a1\u00a2")
        buf.write(u"\5\f\7\2\u00a2\u00a3\7\6\2\2\u00a3\u00a4\5\32\16\2\u00a4")
        buf.write(u"\u00a5\7\16\2\2\u00a5\u00a6\5\n\6\2\u00a6\u00f5\3\2\2")
        buf.write(u"\2\u00a7\u00a8\7\22\2\2\u00a8\u00a9\5\f\7\2\u00a9\u00af")
        buf.write(u"\7\23\2\2\u00aa\u00ab\5\f\7\2\u00ab\u00ac\7\6\2\2\u00ac")
        buf.write(u"\u00ad\5\n\6\2\u00ad\u00ae\7\3\2\2\u00ae\u00b0\3\2\2")
        buf.write(u"\2\u00af\u00aa\3\2\2\2\u00b0\u00b1\3\2\2\2\u00b1\u00af")
        buf.write(u"\3\2\2\2\u00b1\u00b2\3\2\2\2\u00b2\u00b3\3\2\2\2\u00b3")
        buf.write(u"\u00b4\5\f\7\2\u00b4\u00b5\7\6\2\2\u00b5\u00b6\5\n\6")
        buf.write(u"\2\u00b6\u00b7\7\24\2\2\u00b7\u00f5\3\2\2\2\u00b8\u00b9")
        buf.write(u"\7\25\2\2\u00b9\u00ba\5\f\7\2\u00ba\u00bb\7\3\2\2\u00bb")
        buf.write(u"\u00bc\5\f\7\2\u00bc\u00bd\7\16\2\2\u00bd\u00be\5\n\6")
        buf.write(u"\2\u00be\u00f5\3\2\2\2\u00bf\u00c0\7\17\2\2\u00c0\u00c1")
        buf.write(u"\5\f\7\2\u00c1\u00c2\7\6\2\2\u00c2\u00c3\5\30\r\2\u00c3")
        buf.write(u"\u00c4\7\20\2\2\u00c4\u00c5\5\b\5\2\u00c5\u00c6\7\13")
        buf.write(u"\2\2\u00c6\u00f5\3\2\2\2\u00c7\u00c8\7\21\2\2\u00c8\u00ce")
        buf.write(u"\5\f\7\2\u00c9\u00ca\7\3\2\2\u00ca\u00cb\5\f\7\2\u00cb")
        buf.write(u"\u00cc\7\6\2\2\u00cc\u00cd\5\30\r\2\u00cd\u00cf\3\2\2")
        buf.write(u"\2\u00ce\u00c9\3\2\2\2\u00cf\u00d0\3\2\2\2\u00d0\u00ce")
        buf.write(u"\3\2\2\2\u00d0\u00d1\3\2\2\2\u00d1\u00d2\3\2\2\2\u00d2")
        buf.write(u"\u00d3\7\16\2\2\u00d3\u00d4\5\n\6\2\u00d4\u00f5\3\2\2")
        buf.write(u"\2\u00d5\u00d6\7\26\2\2\u00d6\u00d7\5\f\7\2\u00d7\u00dd")
        buf.write(u"\7\27\2\2\u00d8\u00d9\5\20\t\2\u00d9\u00da\7\30\2\2\u00da")
        buf.write(u"\u00db\5\n\6\2\u00db\u00dc\7\3\2\2\u00dc\u00de\3\2\2")
        buf.write(u"\2\u00dd\u00d8\3\2\2\2\u00de\u00df\3\2\2\2\u00df\u00dd")
        buf.write(u"\3\2\2\2\u00df\u00e0\3\2\2\2\u00e0\u00e1\3\2\2\2\u00e1")
        buf.write(u"\u00e2\5\20\t\2\u00e2\u00e3\7\30\2\2\u00e3\u00e4\5\n")
        buf.write(u"\6\2\u00e4\u00e5\7\24\2\2\u00e5\u00f5\3\2\2\2\u00e6\u00e7")
        buf.write(u"\7\r\2\2\u00e7\u00ed\5\f\7\2\u00e8\u00e9\7\3\2\2\u00e9")
        buf.write(u"\u00ea\5\20\t\2\u00ea\u00eb\7\6\2\2\u00eb\u00ec\5\30")
        buf.write(u"\r\2\u00ec\u00ee\3\2\2\2\u00ed\u00e8\3\2\2\2\u00ee\u00ef")
        buf.write(u"\3\2\2\2\u00ef\u00ed\3\2\2\2\u00ef\u00f0\3\2\2\2\u00f0")
        buf.write(u"\u00f1\3\2\2\2\u00f1\u00f2\7\16\2\2\u00f2\u00f3\5\n\6")
        buf.write(u"\2\u00f3\u00f5\3\2\2\2\u00f4t\3\2\2\2\u00f4y\3\2\2\2")
        buf.write(u"\u00f4z\3\2\2\2\u00f4\u0085\3\2\2\2\u00f4\u008d\3\2\2")
        buf.write(u"\2\u00f4\u0096\3\2\2\2\u00f4\u009e\3\2\2\2\u00f4\u00a7")
        buf.write(u"\3\2\2\2\u00f4\u00b8\3\2\2\2\u00f4\u00bf\3\2\2\2\u00f4")
        buf.write(u"\u00c7\3\2\2\2\u00f4\u00d5\3\2\2\2\u00f4\u00e6\3\2\2")
        buf.write(u"\2\u00f5\13\3\2\2\2\u00f6\u0101\7\31\2\2\u00f7\u0101")
        buf.write(u"\7E\2\2\u00f8\u00f9\7\5\2\2\u00f9\u00fa\5\16\b\2\u00fa")
        buf.write(u"\u00fb\7\13\2\2\u00fb\u0101\3\2\2\2\u00fc\u0101\7B\2")
        buf.write(u"\2\u00fd\u0101\7C\2\2\u00fe\u0101\7D\2\2\u00ff\u0101")
        buf.write(u"\5\20\t\2\u0100\u00f6\3\2\2\2\u0100\u00f7\3\2\2\2\u0100")
        buf.write(u"\u00f8\3\2\2\2\u0100\u00fc\3\2\2\2\u0100\u00fd\3\2\2")
        buf.write(u"\2\u0100\u00fe\3\2\2\2\u0100\u00ff\3\2\2\2\u0101\r\3")
        buf.write(u"\2\2\2\u0102\u0103\5\f\7\2\u0103\u0104\7\32\2\2\u0104")
        buf.write(u"\u0105\5\f\7\2\u0105\u0141\3\2\2\2\u0106\u0107\5\f\7")
        buf.write(u"\2\u0107\u0108\7\33\2\2\u0108\u0109\5\f\7\2\u0109\u0141")
        buf.write(u"\3\2\2\2\u010a\u010b\5\f\7\2\u010b\u010c\7\34\2\2\u010c")
        buf.write(u"\u010d\5\f\7\2\u010d\u0141\3\2\2\2\u010e\u010f\5\f\7")
        buf.write(u"\2\u010f\u0110\7\35\2\2\u0110\u0111\5\f\7\2\u0111\u0141")
        buf.write(u"\3\2\2\2\u0112\u0113\5\f\7\2\u0113\u0114\7\31\2\2\u0114")
        buf.write(u"\u0115\5\f\7\2\u0115\u0141\3\2\2\2\u0116\u0117\5\f\7")
        buf.write(u"\2\u0117\u0118\7\36\2\2\u0118\u0119\5\f\7\2\u0119\u0141")
        buf.write(u"\3\2\2\2\u011a\u011b\5\f\7\2\u011b\u011c\7\37\2\2\u011c")
        buf.write(u"\u011d\5\f\7\2\u011d\u0141\3\2\2\2\u011e\u011f\5\f\7")
        buf.write(u"\2\u011f\u0120\7\30\2\2\u0120\u0121\5\f\7\2\u0121\u0141")
        buf.write(u"\3\2\2\2\u0122\u0123\5\f\7\2\u0123\u0124\7 \2\2\u0124")
        buf.write(u"\u0125\5\f\7\2\u0125\u0141\3\2\2\2\u0126\u0127\5\f\7")
        buf.write(u"\2\u0127\u0128\7!\2\2\u0128\u0129\5\f\7\2\u0129\u0141")
        buf.write(u"\3\2\2\2\u012a\u012b\5\f\7\2\u012b\u012c\7\"\2\2\u012c")
        buf.write(u"\u012d\5\f\7\2\u012d\u0141\3\2\2\2\u012e\u012f\5\f\7")
        buf.write(u"\2\u012f\u0130\7#\2\2\u0130\u0131\5\f\7\2\u0131\u0141")
        buf.write(u"\3\2\2\2\u0132\u0133\7$\2\2\u0133\u0141\5\f\7\2\u0134")
        buf.write(u"\u0135\5\f\7\2\u0135\u0136\7%\2\2\u0136\u0137\5\f\7\2")
        buf.write(u"\u0137\u0141\3\2\2\2\u0138\u0139\5\f\7\2\u0139\u013a")
        buf.write(u"\7&\2\2\u013a\u013b\5\f\7\2\u013b\u0141\3\2\2\2\u013c")
        buf.write(u"\u013d\5\f\7\2\u013d\u013e\7\'\2\2\u013e\u013f\5\f\7")
        buf.write(u"\2\u013f\u0141\3\2\2\2\u0140\u0102\3\2\2\2\u0140\u0106")
        buf.write(u"\3\2\2\2\u0140\u010a\3\2\2\2\u0140\u010e\3\2\2\2\u0140")
        buf.write(u"\u0112\3\2\2\2\u0140\u0116\3\2\2\2\u0140\u011a\3\2\2")
        buf.write(u"\2\u0140\u011e\3\2\2\2\u0140\u0122\3\2\2\2\u0140\u0126")
        buf.write(u"\3\2\2\2\u0140\u012a\3\2\2\2\u0140\u012e\3\2\2\2\u0140")
        buf.write(u"\u0132\3\2\2\2\u0140\u0134\3\2\2\2\u0140\u0138\3\2\2")
        buf.write(u"\2\u0140\u013c\3\2\2\2\u0141\17\3\2\2\2\u0142\u0143\7")
        buf.write(u"E\2\2\u0143\u0144\7(\2\2\u0144\u014d\5\f\7\2\u0145\u0146")
        buf.write(u"\7E\2\2\u0146\u0147\7)\2\2\u0147\u0148\5\f\7\2\u0148")
        buf.write(u"\u0149\7\6\2\2\u0149\u014a\5\30\r\2\u014a\u014b\7\13")
        buf.write(u"\2\2\u014b\u014d\3\2\2\2\u014c\u0142\3\2\2\2\u014c\u0145")
        buf.write(u"\3\2\2\2\u014d\21\3\2\2\2\u014e\u0153\7*\2\2\u014f\u0153")
        buf.write(u"\7+\2\2\u0150\u0153\7,\2\2\u0151\u0153\7-\2\2\u0152\u014e")
        buf.write(u"\3\2\2\2\u0152\u014f\3\2\2\2\u0152\u0150\3\2\2\2\u0152")
        buf.write(u"\u0151\3\2\2\2\u0153\23\3\2\2\2\u0154\u0159\7.\2\2\u0155")
        buf.write(u"\u0159\7/\2\2\u0156\u0159\7\60\2\2\u0157\u0159\7\61\2")
        buf.write(u"\2\u0158\u0154\3\2\2\2\u0158\u0155\3\2\2\2\u0158\u0156")
        buf.write(u"\3\2\2\2\u0158\u0157\3\2\2\2\u0159\25\3\2\2\2\u015a\u015b")
        buf.write(u"\7E\2\2\u015b\27\3\2\2\2\u015c\u019f\5\26\f\2\u015d\u0163")
        buf.write(u"\7\62\2\2\u015e\u015f\5\30\r\2\u015f\u0160\7\3\2\2\u0160")
        buf.write(u"\u0162\3\2\2\2\u0161\u015e\3\2\2\2\u0162\u0165\3\2\2")
        buf.write(u"\2\u0163\u0161\3\2\2\2\u0163\u0164\3\2\2\2\u0164\u0166")
        buf.write(u"\3\2\2\2\u0165\u0163\3\2\2\2\u0166\u0167\5\30\r\2\u0167")
        buf.write(u"\u0168\7\63\2\2\u0168\u019f\3\2\2\2\u0169\u016f\7\64")
        buf.write(u"\2\2\u016a\u016b\5\30\r\2\u016b\u016c\7\3\2\2\u016c\u016e")
        buf.write(u"\3\2\2\2\u016d\u016a\3\2\2\2\u016e\u0171\3\2\2\2\u016f")
        buf.write(u"\u016d\3\2\2\2\u016f\u0170\3\2\2\2\u0170\u0172\3\2\2")
        buf.write(u"\2\u0171\u016f\3\2\2\2\u0172\u0173\5\30\r\2\u0173\u0174")
        buf.write(u"\7\63\2\2\u0174\u019f\3\2\2\2\u0175\u017b\7\65\2\2\u0176")
        buf.write(u"\u0177\5\30\r\2\u0177\u0178\7\3\2\2\u0178\u017a\3\2\2")
        buf.write(u"\2\u0179\u0176\3\2\2\2\u017a\u017d\3\2\2\2\u017b\u0179")
        buf.write(u"\3\2\2\2\u017b\u017c\3\2\2\2\u017c\u017e\3\2\2\2\u017d")
        buf.write(u"\u017b\3\2\2\2\u017e\u017f\5\30\r\2\u017f\u0180\7\63")
        buf.write(u"\2\2\u0180\u019f\3\2\2\2\u0181\u0187\7\66\2\2\u0182\u0183")
        buf.write(u"\5\30\r\2\u0183\u0184\7\3\2\2\u0184\u0186\3\2\2\2\u0185")
        buf.write(u"\u0182\3\2\2\2\u0186\u0189\3\2\2\2\u0187\u0185\3\2\2")
        buf.write(u"\2\u0187\u0188\3\2\2\2\u0188\u018a\3\2\2\2\u0189\u0187")
        buf.write(u"\3\2\2\2\u018a\u018b\5\30\r\2\u018b\u018c\7\63\2\2\u018c")
        buf.write(u"\u019f\3\2\2\2\u018d\u019f\7\67\2\2\u018e\u0194\7!\2")
        buf.write(u"\2\u018f\u0190\7E\2\2\u0190\u0191\7(\2\2\u0191\u0192")
        buf.write(u"\5\30\r\2\u0192\u0193\7\3\2\2\u0193\u0195\3\2\2\2\u0194")
        buf.write(u"\u018f\3\2\2\2\u0195\u0196\3\2\2\2\u0196\u0194\3\2\2")
        buf.write(u"\2\u0196\u0197\3\2\2\2\u0197\u0198\3\2\2\2\u0198\u0199")
        buf.write(u"\7E\2\2\u0199\u019a\7(\2\2\u019a\u019b\5\30\r\2\u019b")
        buf.write(u"\u019c\7\30\2\2\u019c\u019f\3\2\2\2\u019d\u019f\5\22")
        buf.write(u"\n\2\u019e\u015c\3\2\2\2\u019e\u015d\3\2\2\2\u019e\u0169")
        buf.write(u"\3\2\2\2\u019e\u0175\3\2\2\2\u019e\u0181\3\2\2\2\u019e")
        buf.write(u"\u018d\3\2\2\2\u019e\u018e\3\2\2\2\u019e\u019d\3\2\2")
        buf.write(u"\2\u019f\31\3\2\2\2\u01a0\u01ac\5\26\f\2\u01a1\u01ac")
        buf.write(u"\5\34\17\2\u01a2\u01a3\78\2\2\u01a3\u01a9\5\32\16\2\u01a4")
        buf.write(u"\u01a5\79\2\2\u01a5\u01a6\5\32\16\2\u01a6\u01a7\7\13")
        buf.write(u"\2\2\u01a7\u01a9\3\2\2\2\u01a8\u01a2\3\2\2\2\u01a8\u01a4")
        buf.write(u"\3\2\2\2\u01a9\u01ac\3\2\2\2\u01aa\u01ac\5\24\13\2\u01ab")
        buf.write(u"\u01a0\3\2\2\2\u01ab\u01a1\3\2\2\2\u01ab\u01a8\3\2\2")
        buf.write(u"\2\u01ab\u01aa\3\2\2\2\u01ac\33\3\2\2\2\u01ad\u01e6\5")
        buf.write(u"\26\f\2\u01ae\u01e6\7:\2\2\u01af\u01b0\7;\2\2\u01b0\u01b1")
        buf.write(u"\5\32\16\2\u01b1\u01b2\7<\2\2\u01b2\u01b3\5\34\17\2\u01b3")
        buf.write(u"\u01ba\3\2\2\2\u01b4\u01b5\7=\2\2\u01b5\u01b6\5\32\16")
        buf.write(u"\2\u01b6\u01b7\7\16\2\2\u01b7\u01b8\5\34\17\2\u01b8\u01ba")
        buf.write(u"\3\2\2\2\u01b9\u01af\3\2\2\2\u01b9\u01b4\3\2\2\2\u01ba")
        buf.write(u"\u01e6\3\2\2\2\u01bb\u01bc\7>\2\2\u01bc\u01bd\5\32\16")
        buf.write(u"\2\u01bd\u01be\7<\2\2\u01be\u01bf\5\34\17\2\u01bf\u01c6")
        buf.write(u"\3\2\2\2\u01c0\u01c1\7?\2\2\u01c1\u01c2\5\32\16\2\u01c2")
        buf.write(u"\u01c3\7\16\2\2\u01c3\u01c4\5\34\17\2\u01c4\u01c6\3\2")
        buf.write(u"\2\2\u01c5\u01bb\3\2\2\2\u01c5\u01c0\3\2\2\2\u01c6\u01e6")
        buf.write(u"\3\2\2\2\u01c7\u01cd\7@\2\2\u01c8\u01c9\5\f\7\2\u01c9")
        buf.write(u"\u01ca\7\6\2\2\u01ca\u01cb\5\34\17\2\u01cb\u01cc\7\3")
        buf.write(u"\2\2\u01cc\u01ce\3\2\2\2\u01cd\u01c8\3\2\2\2\u01ce\u01cf")
        buf.write(u"\3\2\2\2\u01cf\u01cd\3\2\2\2\u01cf\u01d0\3\2\2\2\u01d0")
        buf.write(u"\u01d1\3\2\2\2\u01d1\u01d2\5\f\7\2\u01d2\u01d3\7\6\2")
        buf.write(u"\2\u01d3\u01d4\5\34\17\2\u01d4\u01d5\7\24\2\2\u01d5\u01e6")
        buf.write(u"\3\2\2\2\u01d6\u01dc\7A\2\2\u01d7\u01d8\5\f\7\2\u01d8")
        buf.write(u"\u01d9\7\6\2\2\u01d9\u01da\5\34\17\2\u01da\u01db\7\3")
        buf.write(u"\2\2\u01db\u01dd\3\2\2\2\u01dc\u01d7\3\2\2\2\u01dd\u01de")
        buf.write(u"\3\2\2\2\u01de\u01dc\3\2\2\2\u01de\u01df\3\2\2\2\u01df")
        buf.write(u"\u01e0\3\2\2\2\u01e0\u01e1\5\f\7\2\u01e1\u01e2\7\6\2")
        buf.write(u"\2\u01e2\u01e3\5\34\17\2\u01e3\u01e4\7\24\2\2\u01e4\u01e6")
        buf.write(u"\3\2\2\2\u01e5\u01ad\3\2\2\2\u01e5\u01ae\3\2\2\2\u01e5")
        buf.write(u"\u01b9\3\2\2\2\u01e5\u01c5\3\2\2\2\u01e5\u01c7\3\2\2")
        buf.write(u"\2\u01e5\u01d6\3\2\2\2\u01e6\35\3\2\2\2\36\37(ir\u0080")
        buf.write(u"\u00b1\u00d0\u00df\u00ef\u00f4\u0100\u0140\u014c\u0152")
        buf.write(u"\u0158\u0163\u016f\u017b\u0187\u0196\u019e\u01a8\u01ab")
        buf.write(u"\u01b9\u01c5\u01cf\u01de\u01e5")
        return buf.getvalue()


class PiCalcParser ( Parser ):

    grammarFileName = "PiCalc.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"','", u"'='", u"'('", u"':'", u"') :='", 
                     u"'type '", u"':='", u"'|'", u"')'", u"'stop'", u"'send('", 
                     u"').'", u"'(new '", u"') ('", u"'receive('", u"'branch('", 
                     u"'){'", u"'}'", u"'select('", u"'case '", u"' of {'", 
                     u"'>'", u"'*'", u"'=='", u"'!='", u"'+'", u"'-'", u"'/'", 
                     u"'%'", u"'>='", u"'<'", u"'<='", u"'++'", u"'NOT '", 
                     u"' AND '", u"' OR '", u"' XOR '", u"'_'", u"'_('", 
                     u"'lUnit'", u"'lBool'", u"'lInt'", u"'lString'", u"'sUnit'", 
                     u"'sBool'", u"'sInt'", u"'sString'", u"'lo['", u"']'", 
                     u"'li['", u"'l#['", u"'#['", u"'empty[]'", u"'#'", 
                     u"'#('", u"'end'", u"'?'", u"'.'", u"'?('", u"'!'", 
                     u"'!('", u"'&{'", u"'+{'" ]

    symbolicNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                      u"StringVal", u"IntVal", u"BooleanVal", u"ID", u"WS" ]

    RULE_encInput = 0
    RULE_decls = 1
    RULE_declAssign = 2
    RULE_processPrim = 3
    RULE_processSec = 4
    RULE_value = 5
    RULE_expression = 6
    RULE_variantVal = 7
    RULE_basicLType = 8
    RULE_basicSType = 9
    RULE_namedType = 10
    RULE_linearType = 11
    RULE_tType = 12
    RULE_sType = 13

    ruleNames =  [ u"encInput", u"decls", u"declAssign", u"processPrim", 
                   u"processSec", u"value", u"expression", u"variantVal", 
                   u"basicLType", u"basicSType", u"namedType", u"linearType", 
                   u"tType", u"sType" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    StringVal=64
    IntVal=65
    BooleanVal=66
    ID=67
    WS=68

    def __init__(self, input, output=sys.stdout):
        super(PiCalcParser, self).__init__(input, output=output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class EncInputContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.EncInputContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PiCalcParser.RULE_encInput

     
        def copyFrom(self, ctx):
            super(PiCalcParser.EncInputContext, self).copyFrom(ctx)



    class DeclAndProcsContext(EncInputContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.EncInputContext)
            super(PiCalcParser.DeclAndProcsContext, self).__init__(parser)
            self.copyFrom(ctx)

        def processPrim(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessPrimContext,0)

        def decls(self):
            return self.getTypedRuleContext(PiCalcParser.DeclsContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterDeclAndProcs"):
                listener.enterDeclAndProcs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitDeclAndProcs"):
                listener.exitDeclAndProcs(self)



    def encInput(self):

        localctx = PiCalcParser.EncInputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_encInput)
        try:
            localctx = PiCalcParser.DeclAndProcsContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 29
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 28
                self.decls()


            self.state = 31
            self.processPrim()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.DeclsContext, self).__init__(parent, invokingState)
            self.parser = parser
            self._declAssign = None # DeclAssignContext
            self.decs = list() # of DeclAssignContexts

        def declAssign(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.DeclAssignContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.DeclAssignContext,i)


        def getRuleIndex(self):
            return PiCalcParser.RULE_decls

        def enterRule(self, listener):
            if hasattr(listener, "enterDecls"):
                listener.enterDecls(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitDecls"):
                listener.exitDecls(self)




    def decls(self):

        localctx = PiCalcParser.DeclsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_decls)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 33
            localctx._declAssign = self.declAssign()
            localctx.decs.append(localctx._declAssign)
            self.state = 38
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PiCalcParser.T__0:
                self.state = 34
                self.match(PiCalcParser.T__0)
                self.state = 35
                localctx._declAssign = self.declAssign()
                localctx.decs.append(localctx._declAssign)
                self.state = 40
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclAssignContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.DeclAssignContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PiCalcParser.RULE_declAssign

     
        def copyFrom(self, ctx):
            super(PiCalcParser.DeclAssignContext, self).copyFrom(ctx)



    class ProcessNamingNmdContext(DeclAssignContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.DeclAssignContext)
            super(PiCalcParser.ProcessNamingNmdContext, self).__init__(parser)
            self.name = None # Token
            self.copyFrom(ctx)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def namedType(self):
            return self.getTypedRuleContext(PiCalcParser.NamedTypeContext,0)

        def processPrim(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessPrimContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterProcessNamingNmd"):
                listener.enterProcessNamingNmd(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitProcessNamingNmd"):
                listener.exitProcessNamingNmd(self)


    class LinTypeDeclAndAssignContext(DeclAssignContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.DeclAssignContext)
            super(PiCalcParser.LinTypeDeclAndAssignContext, self).__init__(parser)
            self.var = None # Token
            self.copyFrom(ctx)

        def linearType(self):
            return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,0)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterLinTypeDeclAndAssign"):
                listener.enterLinTypeDeclAndAssign(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLinTypeDeclAndAssign"):
                listener.exitLinTypeDeclAndAssign(self)


    class SessionTypeNamingContext(DeclAssignContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.DeclAssignContext)
            super(PiCalcParser.SessionTypeNamingContext, self).__init__(parser)
            self.name = None # Token
            self.copyFrom(ctx)

        def tType(self):
            return self.getTypedRuleContext(PiCalcParser.TTypeContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterSessionTypeNaming"):
                listener.enterSessionTypeNaming(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSessionTypeNaming"):
                listener.exitSessionTypeNaming(self)


    class ProcessNamingLinContext(DeclAssignContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.DeclAssignContext)
            super(PiCalcParser.ProcessNamingLinContext, self).__init__(parser)
            self.name = None # Token
            self.copyFrom(ctx)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def linearType(self):
            return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,0)

        def processPrim(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessPrimContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterProcessNamingLin"):
                listener.enterProcessNamingLin(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitProcessNamingLin"):
                listener.exitProcessNamingLin(self)


    class ProcessNamingSesContext(DeclAssignContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.DeclAssignContext)
            super(PiCalcParser.ProcessNamingSesContext, self).__init__(parser)
            self.name = None # Token
            self.copyFrom(ctx)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def tType(self):
            return self.getTypedRuleContext(PiCalcParser.TTypeContext,0)

        def processPrim(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessPrimContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterProcessNamingSes"):
                listener.enterProcessNamingSes(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitProcessNamingSes"):
                listener.exitProcessNamingSes(self)


    class NmdTypeDeclAndAssignContext(DeclAssignContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.DeclAssignContext)
            super(PiCalcParser.NmdTypeDeclAndAssignContext, self).__init__(parser)
            self.var = None # Token
            self.copyFrom(ctx)

        def namedType(self):
            return self.getTypedRuleContext(PiCalcParser.NamedTypeContext,0)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterNmdTypeDeclAndAssign"):
                listener.enterNmdTypeDeclAndAssign(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNmdTypeDeclAndAssign"):
                listener.exitNmdTypeDeclAndAssign(self)


    class VariableAssignmentContext(DeclAssignContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.DeclAssignContext)
            super(PiCalcParser.VariableAssignmentContext, self).__init__(parser)
            self.var = None # Token
            self.copyFrom(ctx)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterVariableAssignment"):
                listener.enterVariableAssignment(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitVariableAssignment"):
                listener.exitVariableAssignment(self)


    class LinearTypeNamingContext(DeclAssignContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.DeclAssignContext)
            super(PiCalcParser.LinearTypeNamingContext, self).__init__(parser)
            self.name = None # Token
            self.copyFrom(ctx)

        def linearType(self):
            return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterLinearTypeNaming"):
                listener.enterLinearTypeNaming(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLinearTypeNaming"):
                listener.exitLinearTypeNaming(self)


    class SessionTypeDeclContext(DeclAssignContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.DeclAssignContext)
            super(PiCalcParser.SessionTypeDeclContext, self).__init__(parser)
            self.var = None # Token
            self.copyFrom(ctx)

        def tType(self):
            return self.getTypedRuleContext(PiCalcParser.TTypeContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterSessionTypeDecl"):
                listener.enterSessionTypeDecl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSessionTypeDecl"):
                listener.exitSessionTypeDecl(self)


    class LinearTypeDeclContext(DeclAssignContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.DeclAssignContext)
            super(PiCalcParser.LinearTypeDeclContext, self).__init__(parser)
            self.var = None # Token
            self.copyFrom(ctx)

        def linearType(self):
            return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterLinearTypeDecl"):
                listener.enterLinearTypeDecl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLinearTypeDecl"):
                listener.exitLinearTypeDecl(self)


    class NamedTypeDeclContext(DeclAssignContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.DeclAssignContext)
            super(PiCalcParser.NamedTypeDeclContext, self).__init__(parser)
            self.var = None # Token
            self.copyFrom(ctx)

        def namedType(self):
            return self.getTypedRuleContext(PiCalcParser.NamedTypeContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterNamedTypeDecl"):
                listener.enterNamedTypeDecl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNamedTypeDecl"):
                listener.exitNamedTypeDecl(self)


    class SesTypeDeclAndAssignContext(DeclAssignContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.DeclAssignContext)
            super(PiCalcParser.SesTypeDeclAndAssignContext, self).__init__(parser)
            self.var = None # Token
            self.copyFrom(ctx)

        def tType(self):
            return self.getTypedRuleContext(PiCalcParser.TTypeContext,0)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterSesTypeDeclAndAssign"):
                listener.enterSesTypeDeclAndAssign(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSesTypeDeclAndAssign"):
                listener.exitSesTypeDeclAndAssign(self)



    def declAssign(self):

        localctx = PiCalcParser.DeclAssignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_declAssign)
        try:
            self.state = 103
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                localctx = PiCalcParser.VariableAssignmentContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 41
                localctx.var = self.match(PiCalcParser.ID)
                self.state = 42
                self.match(PiCalcParser.T__1)
                self.state = 43
                self.value()
                pass

            elif la_ == 2:
                localctx = PiCalcParser.ProcessNamingNmdContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 44
                localctx.name = self.match(PiCalcParser.ID)
                self.state = 45
                self.match(PiCalcParser.T__2)
                self.state = 46
                self.value()
                self.state = 47
                self.match(PiCalcParser.T__3)
                self.state = 48
                self.namedType()
                self.state = 49
                self.match(PiCalcParser.T__4)
                self.state = 50
                self.processPrim()
                pass

            elif la_ == 3:
                localctx = PiCalcParser.ProcessNamingSesContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 52
                localctx.name = self.match(PiCalcParser.ID)
                self.state = 53
                self.match(PiCalcParser.T__2)
                self.state = 54
                self.value()
                self.state = 55
                self.match(PiCalcParser.T__3)
                self.state = 56
                self.tType()
                self.state = 57
                self.match(PiCalcParser.T__4)
                self.state = 58
                self.processPrim()
                pass

            elif la_ == 4:
                localctx = PiCalcParser.ProcessNamingLinContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 60
                localctx.name = self.match(PiCalcParser.ID)
                self.state = 61
                self.match(PiCalcParser.T__2)
                self.state = 62
                self.value()
                self.state = 63
                self.match(PiCalcParser.T__3)
                self.state = 64
                self.linearType()
                self.state = 65
                self.match(PiCalcParser.T__4)
                self.state = 66
                self.processPrim()
                pass

            elif la_ == 5:
                localctx = PiCalcParser.SessionTypeNamingContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 68
                self.match(PiCalcParser.T__5)
                self.state = 69
                localctx.name = self.match(PiCalcParser.ID)
                self.state = 70
                self.match(PiCalcParser.T__6)
                self.state = 71
                self.tType()
                pass

            elif la_ == 6:
                localctx = PiCalcParser.LinearTypeNamingContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 72
                self.match(PiCalcParser.T__5)
                self.state = 73
                localctx.name = self.match(PiCalcParser.ID)
                self.state = 74
                self.match(PiCalcParser.T__6)
                self.state = 75
                self.linearType()
                pass

            elif la_ == 7:
                localctx = PiCalcParser.NamedTypeDeclContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 76
                self.match(PiCalcParser.T__5)
                self.state = 77
                localctx.var = self.match(PiCalcParser.ID)
                self.state = 78
                self.namedType()
                pass

            elif la_ == 8:
                localctx = PiCalcParser.NmdTypeDeclAndAssignContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 79
                self.match(PiCalcParser.T__5)
                self.state = 80
                localctx.var = self.match(PiCalcParser.ID)
                self.state = 81
                self.namedType()
                self.state = 82
                self.match(PiCalcParser.T__1)
                self.state = 83
                self.value()
                pass

            elif la_ == 9:
                localctx = PiCalcParser.SessionTypeDeclContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 85
                self.match(PiCalcParser.T__5)
                self.state = 86
                localctx.var = self.match(PiCalcParser.ID)
                self.state = 87
                self.tType()
                pass

            elif la_ == 10:
                localctx = PiCalcParser.SesTypeDeclAndAssignContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 88
                self.match(PiCalcParser.T__5)
                self.state = 89
                localctx.var = self.match(PiCalcParser.ID)
                self.state = 90
                self.tType()
                self.state = 91
                self.match(PiCalcParser.T__1)
                self.state = 92
                self.value()
                pass

            elif la_ == 11:
                localctx = PiCalcParser.LinearTypeDeclContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 94
                self.match(PiCalcParser.T__5)
                self.state = 95
                localctx.var = self.match(PiCalcParser.ID)
                self.state = 96
                self.linearType()
                pass

            elif la_ == 12:
                localctx = PiCalcParser.LinTypeDeclAndAssignContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 97
                self.match(PiCalcParser.T__5)
                self.state = 98
                localctx.var = self.match(PiCalcParser.ID)
                self.state = 99
                self.linearType()
                self.state = 100
                self.match(PiCalcParser.T__1)
                self.state = 101
                self.value()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProcessPrimContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.ProcessPrimContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PiCalcParser.RULE_processPrim

     
        def copyFrom(self, ctx):
            super(PiCalcParser.ProcessPrimContext, self).copyFrom(ctx)



    class SecondaryProcContext(ProcessPrimContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessPrimContext)
            super(PiCalcParser.SecondaryProcContext, self).__init__(parser)
            self.copyFrom(ctx)

        def processSec(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessSecContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterSecondaryProc"):
                listener.enterSecondaryProc(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSecondaryProc"):
                listener.exitSecondaryProc(self)


    class CompositionContext(ProcessPrimContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessPrimContext)
            super(PiCalcParser.CompositionContext, self).__init__(parser)
            self.copyFrom(ctx)

        def processPrim(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ProcessPrimContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ProcessPrimContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterComposition"):
                listener.enterComposition(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitComposition"):
                listener.exitComposition(self)



    def processPrim(self):

        localctx = PiCalcParser.ProcessPrimContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_processPrim)
        try:
            self.state = 112
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PiCalcParser.T__9, PiCalcParser.T__10, PiCalcParser.T__12, PiCalcParser.T__14, PiCalcParser.T__15, PiCalcParser.T__18, PiCalcParser.T__19, PiCalcParser.ID]:
                localctx = PiCalcParser.SecondaryProcContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 105
                self.processSec()
                pass
            elif token in [PiCalcParser.T__2]:
                localctx = PiCalcParser.CompositionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 106
                self.match(PiCalcParser.T__2)
                self.state = 107
                self.processPrim()
                self.state = 108
                self.match(PiCalcParser.T__7)
                self.state = 109
                self.processPrim()
                self.state = 110
                self.match(PiCalcParser.T__8)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProcessSecContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.ProcessSecContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PiCalcParser.RULE_processSec

     
        def copyFrom(self, ctx):
            super(PiCalcParser.ProcessSecContext, self).copyFrom(ctx)



    class BranchingContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.BranchingContext, self).__init__(parser)
            self.channel = None # ValueContext
            self._value = None # ValueContext
            self.opts = list() # of ValueContexts
            self._processSec = None # ProcessSecContext
            self.conts = list() # of ProcessSecContexts
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)

        def processSec(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ProcessSecContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ProcessSecContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterBranching"):
                listener.enterBranching(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBranching"):
                listener.exitBranching(self)


    class SelectionContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.SelectionContext, self).__init__(parser)
            self.channel = None # ValueContext
            self.selection = None # ValueContext
            self.copyFrom(ctx)

        def processSec(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessSecContext,0)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterSelection"):
                listener.enterSelection(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSelection"):
                listener.exitSelection(self)


    class ChannelRestrictionNmdContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.ChannelRestrictionNmdContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def namedType(self):
            return self.getTypedRuleContext(PiCalcParser.NamedTypeContext,0)

        def processPrim(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessPrimContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterChannelRestrictionNmd"):
                listener.enterChannelRestrictionNmd(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitChannelRestrictionNmd"):
                listener.exitChannelRestrictionNmd(self)


    class TerminationContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.TerminationContext, self).__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener):
            if hasattr(listener, "enterTermination"):
                listener.enterTermination(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTermination"):
                listener.exitTermination(self)


    class ChannelRestrictionSesContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.ChannelRestrictionSesContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def tType(self):
            return self.getTypedRuleContext(PiCalcParser.TTypeContext,0)

        def processPrim(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessPrimContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterChannelRestrictionSes"):
                listener.enterChannelRestrictionSes(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitChannelRestrictionSes"):
                listener.exitChannelRestrictionSes(self)


    class InputLinContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.InputLinContext, self).__init__(parser)
            self.channel = None # ValueContext
            self._value = None # ValueContext
            self.payloads = list() # of ValueContexts
            self._linearType = None # LinearTypeContext
            self.plTypes = list() # of LinearTypeContexts
            self.copyFrom(ctx)

        def processSec(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessSecContext,0)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)

        def linearType(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.LinearTypeContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterInputLin"):
                listener.enterInputLin(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInputLin"):
                listener.exitInputLin(self)


    class CaseContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.CaseContext, self).__init__(parser)
            self.case = None # ValueContext
            self._variantVal = None # VariantValContext
            self.opts = list() # of VariantValContexts
            self._processSec = None # ProcessSecContext
            self.conts = list() # of ProcessSecContexts
            self.copyFrom(ctx)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def variantVal(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.VariantValContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.VariantValContext,i)

        def processSec(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ProcessSecContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ProcessSecContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterCase"):
                listener.enterCase(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCase"):
                listener.exitCase(self)


    class SessionRestrictionContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.SessionRestrictionContext, self).__init__(parser)
            self._value = None # ValueContext
            self.endpoint = list() # of ValueContexts
            self.copyFrom(ctx)

        def sType(self):
            return self.getTypedRuleContext(PiCalcParser.STypeContext,0)

        def processPrim(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessPrimContext,0)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterSessionRestriction"):
                listener.enterSessionRestriction(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSessionRestriction"):
                listener.exitSessionRestriction(self)


    class OutputContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.OutputContext, self).__init__(parser)
            self.channel = None # ValueContext
            self._value = None # ValueContext
            self.payloads = list() # of ValueContexts
            self.copyFrom(ctx)

        def processSec(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessSecContext,0)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterOutput"):
                listener.enterOutput(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOutput"):
                listener.exitOutput(self)


    class ChannelRestrictionLinContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.ChannelRestrictionLinContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def linearType(self):
            return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,0)

        def processPrim(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessPrimContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterChannelRestrictionLin"):
                listener.enterChannelRestrictionLin(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitChannelRestrictionLin"):
                listener.exitChannelRestrictionLin(self)


    class OutputVariantsContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.OutputVariantsContext, self).__init__(parser)
            self.channel = None # ValueContext
            self._variantVal = None # VariantValContext
            self.payloads = list() # of VariantValContexts
            self._linearType = None # LinearTypeContext
            self.plTypes = list() # of LinearTypeContexts
            self.copyFrom(ctx)

        def processSec(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessSecContext,0)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def variantVal(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.VariantValContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.VariantValContext,i)

        def linearType(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.LinearTypeContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterOutputVariants"):
                listener.enterOutputVariants(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOutputVariants"):
                listener.exitOutputVariants(self)


    class NamedProcessContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.NamedProcessContext, self).__init__(parser)
            self.name = None # Token
            self.copyFrom(ctx)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterNamedProcess"):
                listener.enterNamedProcess(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNamedProcess"):
                listener.exitNamedProcess(self)


    class InputSesContext(ProcessSecContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ProcessSecContext)
            super(PiCalcParser.InputSesContext, self).__init__(parser)
            self.channel = None # ValueContext
            self.payload = None # ValueContext
            self.plType = None # TTypeContext
            self.copyFrom(ctx)

        def processSec(self):
            return self.getTypedRuleContext(PiCalcParser.ProcessSecContext,0)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)

        def tType(self):
            return self.getTypedRuleContext(PiCalcParser.TTypeContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterInputSes"):
                listener.enterInputSes(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInputSes"):
                listener.exitInputSes(self)



    def processSec(self):

        localctx = PiCalcParser.ProcessSecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_processSec)
        self._la = 0 # Token type
        try:
            self.state = 242
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                localctx = PiCalcParser.NamedProcessContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 114
                localctx.name = self.match(PiCalcParser.ID)
                self.state = 115
                self.match(PiCalcParser.T__2)
                self.state = 116
                self.value()
                self.state = 117
                self.match(PiCalcParser.T__8)
                pass

            elif la_ == 2:
                localctx = PiCalcParser.TerminationContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 119
                self.match(PiCalcParser.T__9)
                pass

            elif la_ == 3:
                localctx = PiCalcParser.OutputContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 120
                self.match(PiCalcParser.T__10)
                self.state = 121
                localctx.channel = self.value()
                self.state = 124 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 122
                    self.match(PiCalcParser.T__0)
                    self.state = 123
                    localctx._value = self.value()
                    localctx.payloads.append(localctx._value)
                    self.state = 126 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==PiCalcParser.T__0):
                        break

                self.state = 128
                self.match(PiCalcParser.T__11)
                self.state = 129
                self.processSec()
                pass

            elif la_ == 4:
                localctx = PiCalcParser.ChannelRestrictionNmdContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 131
                self.match(PiCalcParser.T__12)
                self.state = 132
                self.value()
                self.state = 133
                self.match(PiCalcParser.T__3)
                self.state = 134
                self.namedType()
                self.state = 135
                self.match(PiCalcParser.T__13)
                self.state = 136
                self.processPrim()
                self.state = 137
                self.match(PiCalcParser.T__8)
                pass

            elif la_ == 5:
                localctx = PiCalcParser.SessionRestrictionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 139
                self.match(PiCalcParser.T__12)
                self.state = 140
                localctx._value = self.value()
                localctx.endpoint.append(localctx._value)
                self.state = 141
                localctx._value = self.value()
                localctx.endpoint.append(localctx._value)
                self.state = 142
                self.match(PiCalcParser.T__3)
                self.state = 143
                self.sType()
                self.state = 144
                self.match(PiCalcParser.T__13)
                self.state = 145
                self.processPrim()
                self.state = 146
                self.match(PiCalcParser.T__8)
                pass

            elif la_ == 6:
                localctx = PiCalcParser.ChannelRestrictionSesContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 148
                self.match(PiCalcParser.T__12)
                self.state = 149
                self.value()
                self.state = 150
                self.match(PiCalcParser.T__3)
                self.state = 151
                self.tType()
                self.state = 152
                self.match(PiCalcParser.T__13)
                self.state = 153
                self.processPrim()
                self.state = 154
                self.match(PiCalcParser.T__8)
                pass

            elif la_ == 7:
                localctx = PiCalcParser.InputSesContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 156
                self.match(PiCalcParser.T__14)
                self.state = 157
                localctx.channel = self.value()
                self.state = 158
                self.match(PiCalcParser.T__0)
                self.state = 159
                localctx.payload = self.value()
                self.state = 160
                self.match(PiCalcParser.T__3)
                self.state = 161
                localctx.plType = self.tType()
                self.state = 162
                self.match(PiCalcParser.T__11)
                self.state = 163
                self.processSec()
                pass

            elif la_ == 8:
                localctx = PiCalcParser.BranchingContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 165
                self.match(PiCalcParser.T__15)
                self.state = 166
                localctx.channel = self.value()
                self.state = 167
                self.match(PiCalcParser.T__16)
                self.state = 173 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 168
                        localctx._value = self.value()
                        localctx.opts.append(localctx._value)
                        self.state = 169
                        self.match(PiCalcParser.T__3)
                        self.state = 170
                        localctx._processSec = self.processSec()
                        localctx.conts.append(localctx._processSec)
                        self.state = 171
                        self.match(PiCalcParser.T__0)

                    else:
                        raise NoViableAltException(self)
                    self.state = 175 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

                self.state = 177
                localctx._value = self.value()
                localctx.opts.append(localctx._value)
                self.state = 178
                self.match(PiCalcParser.T__3)
                self.state = 179
                localctx._processSec = self.processSec()
                localctx.conts.append(localctx._processSec)
                self.state = 180
                self.match(PiCalcParser.T__17)
                pass

            elif la_ == 9:
                localctx = PiCalcParser.SelectionContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 182
                self.match(PiCalcParser.T__18)
                self.state = 183
                localctx.channel = self.value()
                self.state = 184
                self.match(PiCalcParser.T__0)
                self.state = 185
                localctx.selection = self.value()
                self.state = 186
                self.match(PiCalcParser.T__11)
                self.state = 187
                self.processSec()
                pass

            elif la_ == 10:
                localctx = PiCalcParser.ChannelRestrictionLinContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 189
                self.match(PiCalcParser.T__12)
                self.state = 190
                self.value()
                self.state = 191
                self.match(PiCalcParser.T__3)
                self.state = 192
                self.linearType()
                self.state = 193
                self.match(PiCalcParser.T__13)
                self.state = 194
                self.processPrim()
                self.state = 195
                self.match(PiCalcParser.T__8)
                pass

            elif la_ == 11:
                localctx = PiCalcParser.InputLinContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 197
                self.match(PiCalcParser.T__14)
                self.state = 198
                localctx.channel = self.value()
                self.state = 204 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 199
                    self.match(PiCalcParser.T__0)
                    self.state = 200
                    localctx._value = self.value()
                    localctx.payloads.append(localctx._value)
                    self.state = 201
                    self.match(PiCalcParser.T__3)
                    self.state = 202
                    localctx._linearType = self.linearType()
                    localctx.plTypes.append(localctx._linearType)
                    self.state = 206 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==PiCalcParser.T__0):
                        break

                self.state = 208
                self.match(PiCalcParser.T__11)
                self.state = 209
                self.processSec()
                pass

            elif la_ == 12:
                localctx = PiCalcParser.CaseContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 211
                self.match(PiCalcParser.T__19)
                self.state = 212
                localctx.case = self.value()
                self.state = 213
                self.match(PiCalcParser.T__20)
                self.state = 219 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 214
                        localctx._variantVal = self.variantVal()
                        localctx.opts.append(localctx._variantVal)
                        self.state = 215
                        self.match(PiCalcParser.T__21)
                        self.state = 216
                        localctx._processSec = self.processSec()
                        localctx.conts.append(localctx._processSec)
                        self.state = 217
                        self.match(PiCalcParser.T__0)

                    else:
                        raise NoViableAltException(self)
                    self.state = 221 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

                self.state = 223
                localctx._variantVal = self.variantVal()
                localctx.opts.append(localctx._variantVal)
                self.state = 224
                self.match(PiCalcParser.T__21)
                self.state = 225
                localctx._processSec = self.processSec()
                localctx.conts.append(localctx._processSec)
                self.state = 226
                self.match(PiCalcParser.T__17)
                pass

            elif la_ == 13:
                localctx = PiCalcParser.OutputVariantsContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 228
                self.match(PiCalcParser.T__10)
                self.state = 229
                localctx.channel = self.value()
                self.state = 235 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 230
                    self.match(PiCalcParser.T__0)
                    self.state = 231
                    localctx._variantVal = self.variantVal()
                    localctx.payloads.append(localctx._variantVal)
                    self.state = 232
                    self.match(PiCalcParser.T__3)
                    self.state = 233
                    localctx._linearType = self.linearType()
                    localctx.plTypes.append(localctx._linearType)
                    self.state = 237 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==PiCalcParser.T__0):
                        break

                self.state = 239
                self.match(PiCalcParser.T__11)
                self.state = 240
                self.processSec()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ValueContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.ValueContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PiCalcParser.RULE_value

     
        def copyFrom(self, ctx):
            super(PiCalcParser.ValueContext, self).copyFrom(ctx)



    class ExprValueContext(ValueContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ValueContext)
            super(PiCalcParser.ExprValueContext, self).__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(PiCalcParser.ExpressionContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterExprValue"):
                listener.enterExprValue(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitExprValue"):
                listener.exitExprValue(self)


    class IntegerValueContext(ValueContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ValueContext)
            super(PiCalcParser.IntegerValueContext, self).__init__(parser)
            self.copyFrom(ctx)

        def IntVal(self):
            return self.getToken(PiCalcParser.IntVal, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterIntegerValue"):
                listener.enterIntegerValue(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntegerValue"):
                listener.exitIntegerValue(self)


    class BooleanValueContext(ValueContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ValueContext)
            super(PiCalcParser.BooleanValueContext, self).__init__(parser)
            self.copyFrom(ctx)

        def BooleanVal(self):
            return self.getToken(PiCalcParser.BooleanVal, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterBooleanValue"):
                listener.enterBooleanValue(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBooleanValue"):
                listener.exitBooleanValue(self)


    class UnitValueContext(ValueContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ValueContext)
            super(PiCalcParser.UnitValueContext, self).__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener):
            if hasattr(listener, "enterUnitValue"):
                listener.enterUnitValue(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitUnitValue"):
                listener.exitUnitValue(self)


    class NamedValueContext(ValueContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ValueContext)
            super(PiCalcParser.NamedValueContext, self).__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterNamedValue"):
                listener.enterNamedValue(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNamedValue"):
                listener.exitNamedValue(self)


    class VariantValueContext(ValueContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ValueContext)
            super(PiCalcParser.VariantValueContext, self).__init__(parser)
            self.copyFrom(ctx)

        def variantVal(self):
            return self.getTypedRuleContext(PiCalcParser.VariantValContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterVariantValue"):
                listener.enterVariantValue(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitVariantValue"):
                listener.exitVariantValue(self)


    class StringValueContext(ValueContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ValueContext)
            super(PiCalcParser.StringValueContext, self).__init__(parser)
            self.copyFrom(ctx)

        def StringVal(self):
            return self.getToken(PiCalcParser.StringVal, 0)

        def enterRule(self, listener):
            if hasattr(listener, "enterStringValue"):
                listener.enterStringValue(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStringValue"):
                listener.exitStringValue(self)



    def value(self):

        localctx = PiCalcParser.ValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_value)
        try:
            self.state = 254
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                localctx = PiCalcParser.UnitValueContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 244
                self.match(PiCalcParser.T__22)
                pass

            elif la_ == 2:
                localctx = PiCalcParser.NamedValueContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 245
                self.match(PiCalcParser.ID)
                pass

            elif la_ == 3:
                localctx = PiCalcParser.ExprValueContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 246
                self.match(PiCalcParser.T__2)
                self.state = 247
                self.expression()
                self.state = 248
                self.match(PiCalcParser.T__8)
                pass

            elif la_ == 4:
                localctx = PiCalcParser.StringValueContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 250
                self.match(PiCalcParser.StringVal)
                pass

            elif la_ == 5:
                localctx = PiCalcParser.IntegerValueContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 251
                self.match(PiCalcParser.IntVal)
                pass

            elif la_ == 6:
                localctx = PiCalcParser.BooleanValueContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 252
                self.match(PiCalcParser.BooleanVal)
                pass

            elif la_ == 7:
                localctx = PiCalcParser.VariantValueContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 253
                self.variantVal()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.ExpressionContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PiCalcParser.RULE_expression

     
        def copyFrom(self, ctx):
            super(PiCalcParser.ExpressionContext, self).copyFrom(ctx)



    class EqlContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.EqlContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterEql"):
                listener.enterEql(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitEql"):
                listener.exitEql(self)


    class IntLTEqContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.IntLTEqContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterIntLTEq"):
                listener.enterIntLTEq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntLTEq"):
                listener.exitIntLTEq(self)


    class BoolXorContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.BoolXorContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterBoolXor"):
                listener.enterBoolXor(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBoolXor"):
                listener.exitBoolXor(self)


    class IntSubContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.IntSubContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterIntSub"):
                listener.enterIntSub(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntSub"):
                listener.exitIntSub(self)


    class IntGTContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.IntGTContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterIntGT"):
                listener.enterIntGT(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntGT"):
                listener.exitIntGT(self)


    class IntModContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.IntModContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterIntMod"):
                listener.enterIntMod(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntMod"):
                listener.exitIntMod(self)


    class StrConcatContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.StrConcatContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterStrConcat"):
                listener.enterStrConcat(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStrConcat"):
                listener.exitStrConcat(self)


    class IntAddContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.IntAddContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterIntAdd"):
                listener.enterIntAdd(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntAdd"):
                listener.exitIntAdd(self)


    class IntGTEqContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.IntGTEqContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterIntGTEq"):
                listener.enterIntGTEq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntGTEq"):
                listener.exitIntGTEq(self)


    class InEqlContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.InEqlContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterInEql"):
                listener.enterInEql(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInEql"):
                listener.exitInEql(self)


    class IntLTContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.IntLTContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterIntLT"):
                listener.enterIntLT(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntLT"):
                listener.exitIntLT(self)


    class IntDivContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.IntDivContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterIntDiv"):
                listener.enterIntDiv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntDiv"):
                listener.exitIntDiv(self)


    class BoolNotContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.BoolNotContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterBoolNot"):
                listener.enterBoolNot(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBoolNot"):
                listener.exitBoolNot(self)


    class IntMultContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.IntMultContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterIntMult"):
                listener.enterIntMult(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntMult"):
                listener.exitIntMult(self)


    class BoolOrContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.BoolOrContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterBoolOr"):
                listener.enterBoolOr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBoolOr"):
                listener.exitBoolOr(self)


    class BoolAndContext(ExpressionContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.ExpressionContext)
            super(PiCalcParser.BoolAndContext, self).__init__(parser)
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterBoolAnd"):
                listener.enterBoolAnd(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBoolAnd"):
                listener.exitBoolAnd(self)



    def expression(self):

        localctx = PiCalcParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_expression)
        try:
            self.state = 318
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                localctx = PiCalcParser.EqlContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 256
                self.value()
                self.state = 257
                self.match(PiCalcParser.T__23)
                self.state = 258
                self.value()
                pass

            elif la_ == 2:
                localctx = PiCalcParser.InEqlContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 260
                self.value()
                self.state = 261
                self.match(PiCalcParser.T__24)
                self.state = 262
                self.value()
                pass

            elif la_ == 3:
                localctx = PiCalcParser.IntAddContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 264
                self.value()
                self.state = 265
                self.match(PiCalcParser.T__25)
                self.state = 266
                self.value()
                pass

            elif la_ == 4:
                localctx = PiCalcParser.IntSubContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 268
                self.value()
                self.state = 269
                self.match(PiCalcParser.T__26)
                self.state = 270
                self.value()
                pass

            elif la_ == 5:
                localctx = PiCalcParser.IntMultContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 272
                self.value()
                self.state = 273
                self.match(PiCalcParser.T__22)
                self.state = 274
                self.value()
                pass

            elif la_ == 6:
                localctx = PiCalcParser.IntDivContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 276
                self.value()
                self.state = 277
                self.match(PiCalcParser.T__27)
                self.state = 278
                self.value()
                pass

            elif la_ == 7:
                localctx = PiCalcParser.IntModContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 280
                self.value()
                self.state = 281
                self.match(PiCalcParser.T__28)
                self.state = 282
                self.value()
                pass

            elif la_ == 8:
                localctx = PiCalcParser.IntGTContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 284
                self.value()
                self.state = 285
                self.match(PiCalcParser.T__21)
                self.state = 286
                self.value()
                pass

            elif la_ == 9:
                localctx = PiCalcParser.IntGTEqContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 288
                self.value()
                self.state = 289
                self.match(PiCalcParser.T__29)
                self.state = 290
                self.value()
                pass

            elif la_ == 10:
                localctx = PiCalcParser.IntLTContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 292
                self.value()
                self.state = 293
                self.match(PiCalcParser.T__30)
                self.state = 294
                self.value()
                pass

            elif la_ == 11:
                localctx = PiCalcParser.IntLTEqContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 296
                self.value()
                self.state = 297
                self.match(PiCalcParser.T__31)
                self.state = 298
                self.value()
                pass

            elif la_ == 12:
                localctx = PiCalcParser.StrConcatContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 300
                self.value()
                self.state = 301
                self.match(PiCalcParser.T__32)
                self.state = 302
                self.value()
                pass

            elif la_ == 13:
                localctx = PiCalcParser.BoolNotContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 304
                self.match(PiCalcParser.T__33)
                self.state = 305
                self.value()
                pass

            elif la_ == 14:
                localctx = PiCalcParser.BoolAndContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 306
                self.value()
                self.state = 307
                self.match(PiCalcParser.T__34)
                self.state = 308
                self.value()
                pass

            elif la_ == 15:
                localctx = PiCalcParser.BoolOrContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 310
                self.value()
                self.state = 311
                self.match(PiCalcParser.T__35)
                self.state = 312
                self.value()
                pass

            elif la_ == 16:
                localctx = PiCalcParser.BoolXorContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 314
                self.value()
                self.state = 315
                self.match(PiCalcParser.T__36)
                self.state = 316
                self.value()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariantValContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.VariantValContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def value(self):
            return self.getTypedRuleContext(PiCalcParser.ValueContext,0)


        def linearType(self):
            return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,0)


        def getRuleIndex(self):
            return PiCalcParser.RULE_variantVal

        def enterRule(self, listener):
            if hasattr(listener, "enterVariantVal"):
                listener.enterVariantVal(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitVariantVal"):
                listener.exitVariantVal(self)




    def variantVal(self):

        localctx = PiCalcParser.VariantValContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_variantVal)
        try:
            self.state = 330
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 320
                self.match(PiCalcParser.ID)
                self.state = 321
                self.match(PiCalcParser.T__37)
                self.state = 322
                self.value()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 323
                self.match(PiCalcParser.ID)
                self.state = 324
                self.match(PiCalcParser.T__38)
                self.state = 325
                self.value()
                self.state = 326
                self.match(PiCalcParser.T__3)
                self.state = 327
                self.linearType()
                self.state = 328
                self.match(PiCalcParser.T__8)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BasicLTypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.BasicLTypeContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PiCalcParser.RULE_basicLType

     
        def copyFrom(self, ctx):
            super(PiCalcParser.BasicLTypeContext, self).copyFrom(ctx)



    class LBooleanContext(BasicLTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.BasicLTypeContext)
            super(PiCalcParser.LBooleanContext, self).__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener):
            if hasattr(listener, "enterLBoolean"):
                listener.enterLBoolean(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLBoolean"):
                listener.exitLBoolean(self)


    class LUnitTypeContext(BasicLTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.BasicLTypeContext)
            super(PiCalcParser.LUnitTypeContext, self).__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener):
            if hasattr(listener, "enterLUnitType"):
                listener.enterLUnitType(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLUnitType"):
                listener.exitLUnitType(self)


    class LIntegerContext(BasicLTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.BasicLTypeContext)
            super(PiCalcParser.LIntegerContext, self).__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener):
            if hasattr(listener, "enterLInteger"):
                listener.enterLInteger(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLInteger"):
                listener.exitLInteger(self)


    class LStringContext(BasicLTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.BasicLTypeContext)
            super(PiCalcParser.LStringContext, self).__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener):
            if hasattr(listener, "enterLString"):
                listener.enterLString(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLString"):
                listener.exitLString(self)



    def basicLType(self):

        localctx = PiCalcParser.BasicLTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_basicLType)
        try:
            self.state = 336
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PiCalcParser.T__39]:
                localctx = PiCalcParser.LUnitTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 332
                self.match(PiCalcParser.T__39)
                pass
            elif token in [PiCalcParser.T__40]:
                localctx = PiCalcParser.LBooleanContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 333
                self.match(PiCalcParser.T__40)
                pass
            elif token in [PiCalcParser.T__41]:
                localctx = PiCalcParser.LIntegerContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 334
                self.match(PiCalcParser.T__41)
                pass
            elif token in [PiCalcParser.T__42]:
                localctx = PiCalcParser.LStringContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 335
                self.match(PiCalcParser.T__42)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BasicSTypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.BasicSTypeContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PiCalcParser.RULE_basicSType

     
        def copyFrom(self, ctx):
            super(PiCalcParser.BasicSTypeContext, self).copyFrom(ctx)



    class SBooleanContext(BasicSTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.BasicSTypeContext)
            super(PiCalcParser.SBooleanContext, self).__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener):
            if hasattr(listener, "enterSBoolean"):
                listener.enterSBoolean(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSBoolean"):
                listener.exitSBoolean(self)


    class SIntegerContext(BasicSTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.BasicSTypeContext)
            super(PiCalcParser.SIntegerContext, self).__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener):
            if hasattr(listener, "enterSInteger"):
                listener.enterSInteger(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSInteger"):
                listener.exitSInteger(self)


    class SUnitTypeContext(BasicSTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.BasicSTypeContext)
            super(PiCalcParser.SUnitTypeContext, self).__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener):
            if hasattr(listener, "enterSUnitType"):
                listener.enterSUnitType(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSUnitType"):
                listener.exitSUnitType(self)


    class SStringContext(BasicSTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.BasicSTypeContext)
            super(PiCalcParser.SStringContext, self).__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener):
            if hasattr(listener, "enterSString"):
                listener.enterSString(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSString"):
                listener.exitSString(self)



    def basicSType(self):

        localctx = PiCalcParser.BasicSTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_basicSType)
        try:
            self.state = 342
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PiCalcParser.T__43]:
                localctx = PiCalcParser.SUnitTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 338
                self.match(PiCalcParser.T__43)
                pass
            elif token in [PiCalcParser.T__44]:
                localctx = PiCalcParser.SBooleanContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 339
                self.match(PiCalcParser.T__44)
                pass
            elif token in [PiCalcParser.T__45]:
                localctx = PiCalcParser.SIntegerContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 340
                self.match(PiCalcParser.T__45)
                pass
            elif token in [PiCalcParser.T__46]:
                localctx = PiCalcParser.SStringContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 341
                self.match(PiCalcParser.T__46)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NamedTypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.NamedTypeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(PiCalcParser.ID, 0)

        def getRuleIndex(self):
            return PiCalcParser.RULE_namedType

        def enterRule(self, listener):
            if hasattr(listener, "enterNamedType"):
                listener.enterNamedType(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNamedType"):
                listener.exitNamedType(self)




    def namedType(self):

        localctx = PiCalcParser.NamedTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_namedType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 344
            self.match(PiCalcParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LinearTypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.LinearTypeContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PiCalcParser.RULE_linearType

     
        def copyFrom(self, ctx):
            super(PiCalcParser.LinearTypeContext, self).copyFrom(ctx)



    class LinearOutputContext(LinearTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.LinearTypeContext)
            super(PiCalcParser.LinearOutputContext, self).__init__(parser)
            self._linearType = None # LinearTypeContext
            self.payloads = list() # of LinearTypeContexts
            self.copyFrom(ctx)

        def linearType(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.LinearTypeContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterLinearOutput"):
                listener.enterLinearOutput(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLinearOutput"):
                listener.exitLinearOutput(self)


    class LinearInputContext(LinearTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.LinearTypeContext)
            super(PiCalcParser.LinearInputContext, self).__init__(parser)
            self._linearType = None # LinearTypeContext
            self.payloads = list() # of LinearTypeContexts
            self.copyFrom(ctx)

        def linearType(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.LinearTypeContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterLinearInput"):
                listener.enterLinearInput(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLinearInput"):
                listener.exitLinearInput(self)


    class VariantTypeContext(LinearTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.LinearTypeContext)
            super(PiCalcParser.VariantTypeContext, self).__init__(parser)
            self._ID = None # Token
            self.variants = list() # of Tokens
            self._linearType = None # LinearTypeContext
            self.conts = list() # of LinearTypeContexts
            self.copyFrom(ctx)

        def ID(self, i=None):
            if i is None:
                return self.getTokens(PiCalcParser.ID)
            else:
                return self.getToken(PiCalcParser.ID, i)
        def linearType(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.LinearTypeContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterVariantType"):
                listener.enterVariantType(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitVariantType"):
                listener.exitVariantType(self)


    class ConnectionContext(LinearTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.LinearTypeContext)
            super(PiCalcParser.ConnectionContext, self).__init__(parser)
            self._linearType = None # LinearTypeContext
            self.payloads = list() # of LinearTypeContexts
            self.copyFrom(ctx)

        def linearType(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.LinearTypeContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterConnection"):
                listener.enterConnection(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitConnection"):
                listener.exitConnection(self)


    class BasicLinTypeContext(LinearTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.LinearTypeContext)
            super(PiCalcParser.BasicLinTypeContext, self).__init__(parser)
            self.copyFrom(ctx)

        def basicLType(self):
            return self.getTypedRuleContext(PiCalcParser.BasicLTypeContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterBasicLinType"):
                listener.enterBasicLinType(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBasicLinType"):
                listener.exitBasicLinType(self)


    class LinearConnectionContext(LinearTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.LinearTypeContext)
            super(PiCalcParser.LinearConnectionContext, self).__init__(parser)
            self._linearType = None # LinearTypeContext
            self.payloads = list() # of LinearTypeContexts
            self.copyFrom(ctx)

        def linearType(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.LinearTypeContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.LinearTypeContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterLinearConnection"):
                listener.enterLinearConnection(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLinearConnection"):
                listener.exitLinearConnection(self)


    class NoCapabilityContext(LinearTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.LinearTypeContext)
            super(PiCalcParser.NoCapabilityContext, self).__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener):
            if hasattr(listener, "enterNoCapability"):
                listener.enterNoCapability(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNoCapability"):
                listener.exitNoCapability(self)


    class NamedLinTypeContext(LinearTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.LinearTypeContext)
            super(PiCalcParser.NamedLinTypeContext, self).__init__(parser)
            self.copyFrom(ctx)

        def namedType(self):
            return self.getTypedRuleContext(PiCalcParser.NamedTypeContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterNamedLinType"):
                listener.enterNamedLinType(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNamedLinType"):
                listener.exitNamedLinType(self)



    def linearType(self):

        localctx = PiCalcParser.LinearTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_linearType)
        try:
            self.state = 412
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PiCalcParser.ID]:
                localctx = PiCalcParser.NamedLinTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 346
                self.namedType()
                pass
            elif token in [PiCalcParser.T__47]:
                localctx = PiCalcParser.LinearOutputContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 347
                self.match(PiCalcParser.T__47)
                self.state = 353
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 348
                        localctx._linearType = self.linearType()
                        localctx.payloads.append(localctx._linearType)
                        self.state = 349
                        self.match(PiCalcParser.T__0) 
                    self.state = 355
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

                self.state = 356
                localctx._linearType = self.linearType()
                localctx.payloads.append(localctx._linearType)
                self.state = 357
                self.match(PiCalcParser.T__48)
                pass
            elif token in [PiCalcParser.T__49]:
                localctx = PiCalcParser.LinearInputContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 359
                self.match(PiCalcParser.T__49)
                self.state = 365
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 360
                        localctx._linearType = self.linearType()
                        localctx.payloads.append(localctx._linearType)
                        self.state = 361
                        self.match(PiCalcParser.T__0) 
                    self.state = 367
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,16,self._ctx)

                self.state = 368
                localctx._linearType = self.linearType()
                localctx.payloads.append(localctx._linearType)
                self.state = 369
                self.match(PiCalcParser.T__48)
                pass
            elif token in [PiCalcParser.T__50]:
                localctx = PiCalcParser.LinearConnectionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 371
                self.match(PiCalcParser.T__50)
                self.state = 377
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,17,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 372
                        localctx._linearType = self.linearType()
                        localctx.payloads.append(localctx._linearType)
                        self.state = 373
                        self.match(PiCalcParser.T__0) 
                    self.state = 379
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,17,self._ctx)

                self.state = 380
                localctx._linearType = self.linearType()
                localctx.payloads.append(localctx._linearType)
                self.state = 381
                self.match(PiCalcParser.T__48)
                pass
            elif token in [PiCalcParser.T__51]:
                localctx = PiCalcParser.ConnectionContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 383
                self.match(PiCalcParser.T__51)
                self.state = 389
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 384
                        localctx._linearType = self.linearType()
                        localctx.payloads.append(localctx._linearType)
                        self.state = 385
                        self.match(PiCalcParser.T__0) 
                    self.state = 391
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

                self.state = 392
                localctx._linearType = self.linearType()
                localctx.payloads.append(localctx._linearType)
                self.state = 393
                self.match(PiCalcParser.T__48)
                pass
            elif token in [PiCalcParser.T__52]:
                localctx = PiCalcParser.NoCapabilityContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 395
                self.match(PiCalcParser.T__52)
                pass
            elif token in [PiCalcParser.T__30]:
                localctx = PiCalcParser.VariantTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 396
                self.match(PiCalcParser.T__30)
                self.state = 402 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 397
                        localctx._ID = self.match(PiCalcParser.ID)
                        localctx.variants.append(localctx._ID)
                        self.state = 398
                        self.match(PiCalcParser.T__37)
                        self.state = 399
                        localctx._linearType = self.linearType()
                        localctx.conts.append(localctx._linearType)
                        self.state = 400
                        self.match(PiCalcParser.T__0)

                    else:
                        raise NoViableAltException(self)
                    self.state = 404 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

                self.state = 406
                localctx._ID = self.match(PiCalcParser.ID)
                localctx.variants.append(localctx._ID)
                self.state = 407
                self.match(PiCalcParser.T__37)
                self.state = 408
                localctx._linearType = self.linearType()
                localctx.conts.append(localctx._linearType)
                self.state = 409
                self.match(PiCalcParser.T__21)
                pass
            elif token in [PiCalcParser.T__39, PiCalcParser.T__40, PiCalcParser.T__41, PiCalcParser.T__42]:
                localctx = PiCalcParser.BasicLinTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 411
                self.basicLType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TTypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.TTypeContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PiCalcParser.RULE_tType

     
        def copyFrom(self, ctx):
            super(PiCalcParser.TTypeContext, self).copyFrom(ctx)



    class SessionTypeContext(TTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.TTypeContext)
            super(PiCalcParser.SessionTypeContext, self).__init__(parser)
            self.copyFrom(ctx)

        def sType(self):
            return self.getTypedRuleContext(PiCalcParser.STypeContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterSessionType"):
                listener.enterSessionType(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSessionType"):
                listener.exitSessionType(self)


    class NamedTTypeContext(TTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.TTypeContext)
            super(PiCalcParser.NamedTTypeContext, self).__init__(parser)
            self.copyFrom(ctx)

        def namedType(self):
            return self.getTypedRuleContext(PiCalcParser.NamedTypeContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterNamedTType"):
                listener.enterNamedTType(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNamedTType"):
                listener.exitNamedTType(self)


    class ChannelTypeContext(TTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.TTypeContext)
            super(PiCalcParser.ChannelTypeContext, self).__init__(parser)
            self.copyFrom(ctx)

        def tType(self):
            return self.getTypedRuleContext(PiCalcParser.TTypeContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterChannelType"):
                listener.enterChannelType(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitChannelType"):
                listener.exitChannelType(self)


    class BasicSesTypeContext(TTypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.TTypeContext)
            super(PiCalcParser.BasicSesTypeContext, self).__init__(parser)
            self.copyFrom(ctx)

        def basicSType(self):
            return self.getTypedRuleContext(PiCalcParser.BasicSTypeContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterBasicSesType"):
                listener.enterBasicSesType(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBasicSesType"):
                listener.exitBasicSesType(self)



    def tType(self):

        localctx = PiCalcParser.TTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_tType)
        try:
            self.state = 425
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                localctx = PiCalcParser.NamedTTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 414
                self.namedType()
                pass

            elif la_ == 2:
                localctx = PiCalcParser.SessionTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 415
                self.sType()
                pass

            elif la_ == 3:
                localctx = PiCalcParser.ChannelTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 422
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PiCalcParser.T__53]:
                    self.state = 416
                    self.match(PiCalcParser.T__53)
                    self.state = 417
                    self.tType()
                    pass
                elif token in [PiCalcParser.T__54]:
                    self.state = 418
                    self.match(PiCalcParser.T__54)
                    self.state = 419
                    self.tType()
                    self.state = 420
                    self.match(PiCalcParser.T__8)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 4:
                localctx = PiCalcParser.BasicSesTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 424
                self.basicSType()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class STypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiCalcParser.STypeContext, self).__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return PiCalcParser.RULE_sType

     
        def copyFrom(self, ctx):
            super(PiCalcParser.STypeContext, self).copyFrom(ctx)



    class NamedSTypeContext(STypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.STypeContext)
            super(PiCalcParser.NamedSTypeContext, self).__init__(parser)
            self.copyFrom(ctx)

        def namedType(self):
            return self.getTypedRuleContext(PiCalcParser.NamedTypeContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterNamedSType"):
                listener.enterNamedSType(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNamedSType"):
                listener.exitNamedSType(self)


    class BranchContext(STypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.STypeContext)
            super(PiCalcParser.BranchContext, self).__init__(parser)
            self._value = None # ValueContext
            self.opts = list() # of ValueContexts
            self._sType = None # STypeContext
            self.conts = list() # of STypeContexts
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)

        def sType(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.STypeContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.STypeContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterBranch"):
                listener.enterBranch(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBranch"):
                listener.exitBranch(self)


    class ReceiveContext(STypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.STypeContext)
            super(PiCalcParser.ReceiveContext, self).__init__(parser)
            self.payload = None # TTypeContext
            self.copyFrom(ctx)

        def sType(self):
            return self.getTypedRuleContext(PiCalcParser.STypeContext,0)

        def tType(self):
            return self.getTypedRuleContext(PiCalcParser.TTypeContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterReceive"):
                listener.enterReceive(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitReceive"):
                listener.exitReceive(self)


    class SelectContext(STypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.STypeContext)
            super(PiCalcParser.SelectContext, self).__init__(parser)
            self._value = None # ValueContext
            self.opts = list() # of ValueContexts
            self._sType = None # STypeContext
            self.conts = list() # of STypeContexts
            self.copyFrom(ctx)

        def value(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.ValueContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.ValueContext,i)

        def sType(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiCalcParser.STypeContext)
            else:
                return self.getTypedRuleContext(PiCalcParser.STypeContext,i)


        def enterRule(self, listener):
            if hasattr(listener, "enterSelect"):
                listener.enterSelect(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSelect"):
                listener.exitSelect(self)


    class TerminateContext(STypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.STypeContext)
            super(PiCalcParser.TerminateContext, self).__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener):
            if hasattr(listener, "enterTerminate"):
                listener.enterTerminate(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTerminate"):
                listener.exitTerminate(self)


    class SendContext(STypeContext):

        def __init__(self, parser, ctx): # actually a PiCalcParser.STypeContext)
            super(PiCalcParser.SendContext, self).__init__(parser)
            self.payload = None # TTypeContext
            self.copyFrom(ctx)

        def sType(self):
            return self.getTypedRuleContext(PiCalcParser.STypeContext,0)

        def tType(self):
            return self.getTypedRuleContext(PiCalcParser.TTypeContext,0)


        def enterRule(self, listener):
            if hasattr(listener, "enterSend"):
                listener.enterSend(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSend"):
                listener.exitSend(self)



    def sType(self):

        localctx = PiCalcParser.STypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_sType)
        try:
            self.state = 483
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PiCalcParser.ID]:
                localctx = PiCalcParser.NamedSTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 427
                self.namedType()
                pass
            elif token in [PiCalcParser.T__55]:
                localctx = PiCalcParser.TerminateContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 428
                self.match(PiCalcParser.T__55)
                pass
            elif token in [PiCalcParser.T__56, PiCalcParser.T__58]:
                localctx = PiCalcParser.ReceiveContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 439
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PiCalcParser.T__56]:
                    self.state = 429
                    self.match(PiCalcParser.T__56)
                    self.state = 430
                    localctx.payload = self.tType()
                    self.state = 431
                    self.match(PiCalcParser.T__57)
                    self.state = 432
                    self.sType()
                    pass
                elif token in [PiCalcParser.T__58]:
                    self.state = 434
                    self.match(PiCalcParser.T__58)
                    self.state = 435
                    localctx.payload = self.tType()
                    self.state = 436
                    self.match(PiCalcParser.T__11)
                    self.state = 437
                    self.sType()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [PiCalcParser.T__59, PiCalcParser.T__60]:
                localctx = PiCalcParser.SendContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 451
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PiCalcParser.T__59]:
                    self.state = 441
                    self.match(PiCalcParser.T__59)
                    self.state = 442
                    localctx.payload = self.tType()
                    self.state = 443
                    self.match(PiCalcParser.T__57)
                    self.state = 444
                    self.sType()
                    pass
                elif token in [PiCalcParser.T__60]:
                    self.state = 446
                    self.match(PiCalcParser.T__60)
                    self.state = 447
                    localctx.payload = self.tType()
                    self.state = 448
                    self.match(PiCalcParser.T__11)
                    self.state = 449
                    self.sType()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [PiCalcParser.T__61]:
                localctx = PiCalcParser.BranchContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 453
                self.match(PiCalcParser.T__61)
                self.state = 459 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 454
                        localctx._value = self.value()
                        localctx.opts.append(localctx._value)
                        self.state = 455
                        self.match(PiCalcParser.T__3)
                        self.state = 456
                        localctx._sType = self.sType()
                        localctx.conts.append(localctx._sType)
                        self.state = 457
                        self.match(PiCalcParser.T__0)

                    else:
                        raise NoViableAltException(self)
                    self.state = 461 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,25,self._ctx)

                self.state = 463
                localctx._value = self.value()
                localctx.opts.append(localctx._value)
                self.state = 464
                self.match(PiCalcParser.T__3)
                self.state = 465
                localctx._sType = self.sType()
                localctx.conts.append(localctx._sType)
                self.state = 466
                self.match(PiCalcParser.T__17)
                pass
            elif token in [PiCalcParser.T__62]:
                localctx = PiCalcParser.SelectContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 468
                self.match(PiCalcParser.T__62)
                self.state = 474 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 469
                        localctx._value = self.value()
                        localctx.opts.append(localctx._value)
                        self.state = 470
                        self.match(PiCalcParser.T__3)
                        self.state = 471
                        localctx._sType = self.sType()
                        localctx.conts.append(localctx._sType)
                        self.state = 472
                        self.match(PiCalcParser.T__0)

                    else:
                        raise NoViableAltException(self)
                    self.state = 476 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,26,self._ctx)

                self.state = 478
                localctx._value = self.value()
                localctx.opts.append(localctx._value)
                self.state = 479
                self.match(PiCalcParser.T__3)
                self.state = 480
                localctx._sType = self.sType()
                localctx.conts.append(localctx._sType)
                self.state = 481
                self.match(PiCalcParser.T__17)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





